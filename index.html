<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <title>SpinalHDL by SpinalHDL</title>
    <link rel="stylesheet" href="stylesheets/styles.css">
    <link rel="stylesheet" href="stylesheets/github-dark.css">
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.7.1/jquery.min.js"></script>
    <script src="javascripts/respond.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <!--[if lt IE 8]>
    <link rel="stylesheet" href="stylesheets/ie.css">
    <![endif]-->
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

  </head>
  <body>
      <div id="header">
        <nav>
          <li class="fork"><a href="https://github.com/SpinalHDL/SpinalHDL">View On GitHub</a></li>
          <li class="downloads"><a href="https://github.com/SpinalHDL/SpinalHDL/zipball/master">ZIP</a></li>
          <li class="downloads"><a href="https://github.com/SpinalHDL/SpinalHDL/tarball/master">TAR</a></li>
          <li class="title">DOWNLOADS</li>
        </nav>
      </div><!-- end header -->

    <div class="wrapper">

      <section>
        <div id="title">
          <h1>SpinalHDL</h1>
          <p>SpinalHDL</p>
          <hr>
          <span class="credits left">Project maintained by <a href="https://github.com/SpinalHDL">SpinalHDL</a></span>
          <span class="credits right">Hosted on GitHub Pages &mdash; Theme by <a href="https://twitter.com/michigangraham">mattgraham</a></span>
        </div>

        <h1>
<a id="about-spinalhdl" class="anchor" href="#about-spinalhdl" aria-hidden="true"><span class="octicon octicon-link"></span></a>About SpinalHDL</h1>

<p>SpinalHDL is a scala library that allows the user to describe his digital hardware and then generate the corresponding VHDL file.</p>

<h2>
<a id="advantages-over-vhdlverilog" class="anchor" href="#advantages-over-vhdlverilog" aria-hidden="true"><span class="octicon octicon-link"></span></a>Advantages over VHDL/Verilog</h2>

<ul>
<li>No restriction to the genericity of your hardware description by using Scala constructs</li>
<li>No more endless wiring. Create and connect complex buses like AXI in one line.</li>
<li>Evolving capabilities. Create your own buses definition and abstraction layer.</li>
<li>Reduce code size by a high factor, especially for wiring. Allowing you to have a better visibility, more productivity and fewer headaches.</li>
<li>Free and user friendly IDE. Thanks to scala world for auto-completion, error highlight, navigation shortcut and many others</li>
<li>Extract information from your digital design and then generate files that contain information about some latency and addresses</li>
<li>Bidirectional translation between any data type and bits. Useful to load a complex data structure from a CPU interface.</li>
<li>Check for you that there is no combinational loop / latch</li>
<li>Check that there is no user unintentional cross clock domain</li>
</ul>

<h1>
<a id="getting-started" class="anchor" href="#getting-started" aria-hidden="true"><span class="octicon octicon-link"></span></a>Getting started</h1>

<h2>
<a id="links" class="anchor" href="#links" aria-hidden="true"><span class="octicon octicon-link"></span></a>Links</h2>

<ul>
<li>There is a SBT base project                     <br> <a href="https://github.com/SpinalHDL/SpinalBaseProject">https://github.com/SpinalHDL/SpinalBaseProject</a>
</li>
<li>There is a presentation of the language there   <br> <a href="https://github.com/SpinalHDL/SpinalDoc/tree/master/presentation/en">https://github.com/SpinalHDL/SpinalDoc/tree/master/presentation/en</a> (pptx has comments)</li>
<li>There is a small paper about it there           <br> <a href="https://github.com/SpinalHDL/SpinalDoc/tree/master/paper/en">https://github.com/SpinalHDL/SpinalDoc/tree/master/paper/en</a>
</li>
</ul>

<h2>
<a id="basics" class="anchor" href="#basics" aria-hidden="true"><span class="octicon octicon-link"></span></a>Basics</h2>

<ul>
<li>VHDL backend : The digital hardware description is flushed into a synthesizable VHDL file</li>
<li>Base Types : Bool, Bits, UInt, SInt, Enumeration</li>
<li>Bundle : That allow you to describe a data structure with the possibility for each element to specify the direction (in,out). That is useful to describe bus</li>
<li>Reg : Create a register signal</li>
<li>Vec : That allow you to create an array of data</li>
<li>Mem : Give the possibility to manipulate memory</li>
<li>BlackBox : Allow you to instantiate a third party HDL component</li>
</ul>

<h2>
<a id="sbt" class="anchor" href="#sbt" aria-hidden="true"><span class="octicon octicon-link"></span></a>SBT</h2>

<div class="highlight highlight-scala"><pre>scalaVersion <span class="pl-k">:</span><span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>2.11.6<span class="pl-pds">"</span></span>

libraryDependencies <span class="pl-k">++</span><span class="pl-k">=</span> <span class="pl-en">Seq</span>(
  <span class="pl-s"><span class="pl-pds">"</span>com.github.spinalhdl<span class="pl-pds">"</span></span> <span class="pl-k">%</span> <span class="pl-s"><span class="pl-pds">"</span>spinalhdl-core_2.11<span class="pl-pds">"</span></span> <span class="pl-k">%</span> <span class="pl-s"><span class="pl-pds">"</span>latest.release<span class="pl-pds">"</span></span>,
  <span class="pl-s"><span class="pl-pds">"</span>com.github.spinalhdl<span class="pl-pds">"</span></span> <span class="pl-k">%</span> <span class="pl-s"><span class="pl-pds">"</span>spinalhdl-lib_2.11<span class="pl-pds">"</span></span> <span class="pl-k">%</span> <span class="pl-s"><span class="pl-pds">"</span>latest.release<span class="pl-pds">"</span></span>
)</pre></div>

<h2>
<a id="jar" class="anchor" href="#jar" aria-hidden="true"><span class="octicon octicon-link"></span></a>JAR</h2>

<pre><code>https://oss.sonatype.org/content/groups/public/com/github/spinalhdl/spinalhdl-core_2.11/
https://oss.sonatype.org/content/groups/public/com/github/spinalhdl/spinalhdl-lib_2.11/
</code></pre>

<h1>
<a id="examples" class="anchor" href="#examples" aria-hidden="true"><span class="octicon octicon-link"></span></a>Examples</h1>

<h2>
<a id="simple-component" class="anchor" href="#simple-component" aria-hidden="true"><span class="octicon octicon-link"></span></a>Simple component</h2>

<div class="highlight highlight-scala"><pre><span class="pl-c">// spinal.core contain all basics (Bool, UInt, Bundle, Reg, Component, ..)</span>
<span class="pl-k">import</span> <span class="pl-v">spinal.core.</span><span class="pl-v">_  </span>

<span class="pl-c">//A simple component definition</span>
<span class="pl-k">class</span> <span class="pl-en">MyTopLevel</span> <span class="pl-k">extends</span> <span class="pl-e">Component</span> {
  <span class="pl-c">//Define some input/output. Bundle like a VHDL record or a verilog struct.</span>
  <span class="pl-k">val</span> <span class="pl-en">io</span> <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">Bundle</span> {
    <span class="pl-k">val</span> <span class="pl-en">a</span> <span class="pl-k">=</span> in <span class="pl-en">Bool</span>
    <span class="pl-k">val</span> <span class="pl-en">b</span> <span class="pl-k">=</span> in <span class="pl-en">Bool</span>
    <span class="pl-k">val</span> <span class="pl-en">c</span> <span class="pl-k">=</span> out <span class="pl-en">Bool</span>
  }

  <span class="pl-c">//Define some asynchronous logic</span>
  io.c <span class="pl-k">:</span><span class="pl-k">=</span> io.a &amp; io.b
}

<span class="pl-c">//This is the main of the project. It create a instance of MyTopLevel and </span>
<span class="pl-c">//call the SpinalHDL library to flush it into a VHDL file.</span>
<span class="pl-k">object</span> <span class="pl-en">MyMain</span> {
  <span class="pl-k">def</span> <span class="pl-en">main</span>(<span class="pl-v">args</span>: <span class="pl-en">Array</span>[<span class="pl-k">String</span>]) {
    <span class="pl-en">SpinalVhdl</span>(<span class="pl-k">new</span> <span class="pl-en">MyTopLevel)</span>
  }
}</pre></div>

<h2>
<a id="carry-adder" class="anchor" href="#carry-adder" aria-hidden="true"><span class="octicon octicon-link"></span></a>Carry adder</h2>

<div class="highlight highlight-scala"><pre><span class="pl-k">import</span> <span class="pl-v">spinal.core.</span><span class="pl-v">_</span>

<span class="pl-k">class</span> <span class="pl-en">CarryAdder</span>(<span class="pl-v">size</span> : <span class="pl-k">Int</span>) <span class="pl-k">extends</span> <span class="pl-e">Component</span>{
  <span class="pl-k">val</span> <span class="pl-en">io</span> <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">Bundle</span>{
    <span class="pl-k">val</span> <span class="pl-en">a</span> <span class="pl-k">=</span> in <span class="pl-en">UInt</span>(size bit)
    <span class="pl-k">val</span> <span class="pl-en">b</span> <span class="pl-k">=</span> in <span class="pl-en">UInt</span>(size bit)
    <span class="pl-k">val</span> <span class="pl-en">result</span> <span class="pl-k">=</span> out <span class="pl-en">UInt</span>(size bit)      <span class="pl-c">//result = a + b</span>
  }

  <span class="pl-k">var</span> <span class="pl-en">c</span> <span class="pl-k">=</span> <span class="pl-en">False</span>                   <span class="pl-c">//Carry, like a VHDL variable</span>
  <span class="pl-k">for</span> (i <span class="pl-k">&lt;</span><span class="pl-k">-</span> <span class="pl-c1">0</span> until size) {
    <span class="pl-c">//Create some intermediate value in the loop scope.</span>
    <span class="pl-k">val</span> <span class="pl-en">a</span> <span class="pl-k">=</span> io.a(i)  
    <span class="pl-k">val</span> <span class="pl-en">b</span> <span class="pl-k">=</span> io.b(i)  

    <span class="pl-c">//The carry adder's asynchronous logic</span>
    io.result(i) <span class="pl-k">:</span><span class="pl-k">=</span> a ^ b ^ c
    c <span class="pl-k">=</span> (a &amp; b) <span class="pl-k">|</span> (a &amp; c) <span class="pl-k">|</span> (b &amp; c);    <span class="pl-c">//variable assignment</span>
  }
}


<span class="pl-k">object</span> <span class="pl-en">CarryAdderProject</span> {
  <span class="pl-k">def</span> <span class="pl-en">main</span>(<span class="pl-v">args</span>: <span class="pl-en">Array</span>[<span class="pl-k">String</span>]) {
    <span class="pl-en">SpinalVhdl</span>(<span class="pl-k">new</span> <span class="pl-en">CarryAdder</span>(<span class="pl-c1">4</span>))
  }
}</pre></div>

<h2>
<a id="counter-with-parity" class="anchor" href="#counter-with-parity" aria-hidden="true"><span class="octicon octicon-link"></span></a>Counter with parity</h2>

<div class="highlight highlight-scala"><pre><span class="pl-k">class</span> <span class="pl-en">CounterWithParity</span>(<span class="pl-v">size</span> : <span class="pl-k">Int</span>) <span class="pl-k">extends</span> <span class="pl-e">Component</span>{
  <span class="pl-k">val</span> <span class="pl-en">io</span> <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">Bundle</span>{
    <span class="pl-k">val</span> <span class="pl-en">increment</span> <span class="pl-k">=</span> in <span class="pl-en">Bool</span>
    <span class="pl-k">val</span> <span class="pl-en">value</span> <span class="pl-k">=</span> out <span class="pl-en">UInt</span>(size bit)
    <span class="pl-k">val</span> <span class="pl-en">evenParity</span> <span class="pl-k">=</span> out <span class="pl-en">Bool</span>
  }

  <span class="pl-c">//Create a register of UInt(size-1 downto 0) </span>
  <span class="pl-c">//init(0) force it to zero when a reset occur</span>
  <span class="pl-c">//In Spinal, you don't have to play with clock and reset signals each time</span>
  <span class="pl-c">//  you create register. You define a clock domain area and this is done.</span>
  <span class="pl-k">val</span> <span class="pl-en">counter</span> <span class="pl-k">=</span> <span class="pl-en">Reg</span>(<span class="pl-en">UInt</span>(size bit)) init(<span class="pl-c1">0</span>)
  when(io.increment){
    counter <span class="pl-k">:</span><span class="pl-k">=</span> counter <span class="pl-k">+</span> <span class="pl-c1">1</span>
  }

  <span class="pl-c">//Get all bit of counter and then xor them together</span>
  <span class="pl-c">//toBools create a vector of Bool from each bit of counter</span>
  <span class="pl-c">//reduceLeft is a scala function that mix all bit together </span>
  <span class="pl-c">//  from the left to the right</span>
  io.evenParity <span class="pl-k">:</span><span class="pl-k">=</span> counter.toBools.reduceLeft(_ ^ _)   

  io.value <span class="pl-k">:</span><span class="pl-k">=</span> counter
}</pre></div>

<h2>
<a id="interface--custom-data-types--multi-clock-system" class="anchor" href="#interface--custom-data-types--multi-clock-system" aria-hidden="true"><span class="octicon octicon-link"></span></a>Interface / Custom data types / Multi clock system</h2>

<div class="highlight highlight-scala"><pre><span class="pl-c">// spinal.core contain all basics (Bool, UInt, Bundle, Reg, Component, ..)</span>
<span class="pl-k">import</span> <span class="pl-v">spinal.core.</span><span class="pl-v">_</span>

<span class="pl-c">// spinal.lib contain some abstraction built over the spinal.core like</span>
<span class="pl-c">//   utils          : log2up, toGray, fromGray, </span>
<span class="pl-c">//                    majority vote, latency analysis (in cycle)</span>
<span class="pl-c">//   bus            : Flow      (valid, data)</span>
<span class="pl-c">//                    Stream (valid, ready, data)</span>
<span class="pl-c">//                    Flow or Stream of Fragment  ( .. , last, data),</span>
<span class="pl-c">//   abstraction    : counter, timeout,</span>
<span class="pl-c">//   implementation : stream fifo/arbiter/fork, UART controller</span>
<span class="pl-k">import</span> <span class="pl-v">spinal.lib.</span><span class="pl-v">_</span>

<span class="pl-c">//Define custom data types.</span>
<span class="pl-c">//You can use Bundle into Bundle</span>
<span class="pl-k">class</span> <span class="pl-en">MyDataType</span> <span class="pl-k">extends</span> <span class="pl-e">Bundle</span>{
  <span class="pl-k">val</span> <span class="pl-en">a</span> <span class="pl-k">=</span> <span class="pl-en">UInt</span>(<span class="pl-c1">8</span> bit)
  <span class="pl-k">val</span> <span class="pl-en">b</span> <span class="pl-k">=</span> <span class="pl-en">Bool</span>
  <span class="pl-k">val</span> <span class="pl-en">c</span> <span class="pl-k">=</span> <span class="pl-en">Vec</span>(<span class="pl-c1">4</span>,<span class="pl-en">Bool</span>) <span class="pl-c">//Create a array of 4 Bool</span>
}

<span class="pl-k">class</span> <span class="pl-en">MultiClockTopLevel</span> <span class="pl-k">extends</span> <span class="pl-e">Component</span> {
  <span class="pl-k">val</span> <span class="pl-en">io</span> <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">Bundle</span> {
    <span class="pl-k">val</span> <span class="pl-en">clkA</span> <span class="pl-k">=</span> in <span class="pl-en">Bool</span>
    <span class="pl-k">val</span> <span class="pl-en">resetA</span> <span class="pl-k">=</span> in <span class="pl-en">Bool</span>
    <span class="pl-k">val</span> <span class="pl-en">clkB</span> <span class="pl-k">=</span> in <span class="pl-en">Bool</span>
    <span class="pl-k">val</span> <span class="pl-en">resetB</span> <span class="pl-k">=</span> in <span class="pl-en">Bool</span>

    <span class="pl-c">//Create stream interface (valid, ready, data) to transport MyDataType data</span>
    <span class="pl-k">val</span> <span class="pl-en">slaveInteface</span> <span class="pl-k">=</span> slave <span class="pl-en">Stream</span>(<span class="pl-k">new</span> <span class="pl-en">MyDataType)</span>
    <span class="pl-k">val</span> <span class="pl-en">masterInterface</span> <span class="pl-k">=</span> master <span class="pl-en">Stream</span>(<span class="pl-k">new</span> <span class="pl-en">MyDataType)</span>
  }

  <span class="pl-c">//Create clock domains from inputs clocks and resets</span>
  <span class="pl-k">val</span> <span class="pl-en">clockDomainA</span> <span class="pl-k">=</span> <span class="pl-en">ClockDomain</span>(io.clkA,io.resetA)
  <span class="pl-k">val</span> <span class="pl-en">clockDomainB</span> <span class="pl-k">=</span> <span class="pl-en">ClockDomain</span>(io.clkB,io.resetB)

  <span class="pl-c">//Create a fifo able to cross clock domain a stream of MyDataType</span>
  <span class="pl-k">val</span> <span class="pl-en">fifo</span> <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">StreamFifoCC</span>(<span class="pl-k">new</span> <span class="pl-en">MyDataType,16,clockDomainA,clockDomainB)</span>
  fifo.io.push <span class="pl-k">&lt;&lt;</span> io.slaveInteface    <span class="pl-c">//Easy connection provided by Stream library</span>
  fifo.io.pop <span class="pl-k">&gt;&gt;</span> io.masterInterface
}


<span class="pl-k">object</span> <span class="pl-en">MultiClockTopLevel</span> {
  <span class="pl-k">def</span> <span class="pl-en">main</span>(<span class="pl-v">args</span>: <span class="pl-en">Array</span>[<span class="pl-k">String</span>]) {
    <span class="pl-en">SpinalVhdl</span>(<span class="pl-k">new</span> <span class="pl-en">MultiClockTopLevel)</span>
  }
}</pre></div>

<h2>
<a id="dual-clock-fifo" class="anchor" href="#dual-clock-fifo" aria-hidden="true"><span class="octicon octicon-link"></span></a>Dual clock FIFO</h2>

<div class="highlight highlight-scala"><pre><span class="pl-k">import</span> <span class="pl-v">spinal.core.</span><span class="pl-v">_</span>
<span class="pl-k">import</span> <span class="pl-v">spinal.lib.</span><span class="pl-v">_</span>

<span class="pl-k">class</span> <span class="pl-en">StreamFifoCC</span>[<span class="pl-en">T</span> <span class="pl-k">&lt;</span><span class="pl-k">:</span> <span class="pl-en">Data</span>](<span class="pl-v">dataType</span>: <span class="pl-en">T</span>, <span class="pl-v">depth</span>: <span class="pl-k">Int</span>, <span class="pl-v">pushClockDomain</span>: <span class="pl-en">ClockDomain</span>, <span class="pl-v">popClockDomain</span>: <span class="pl-en">ClockDomain</span>) <span class="pl-k">extends</span> <span class="pl-e">Component</span> {
  assert(isPow2(depth))
  assert(depth <span class="pl-k">&gt;=</span> <span class="pl-c1">2</span>)

  <span class="pl-k">val</span> <span class="pl-en">io</span> <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">Bundle</span> {
    <span class="pl-k">val</span> <span class="pl-en">push</span> <span class="pl-k">=</span> slave <span class="pl-en">Stream</span> (dataType)
    <span class="pl-k">val</span> <span class="pl-en">pop</span> <span class="pl-k">=</span> master <span class="pl-en">Stream</span> (dataType)

    <span class="pl-k">val</span> <span class="pl-en">pushOccupancy</span> <span class="pl-k">=</span> out <span class="pl-en">UInt</span> (log2Up(depth) <span class="pl-k">+</span> <span class="pl-c1">1</span> bit)
    <span class="pl-k">val</span> <span class="pl-en">popOccupancy</span> <span class="pl-k">=</span> out <span class="pl-en">UInt</span> (log2Up(depth) <span class="pl-k">+</span> <span class="pl-c1">1</span> bit)
  }

  <span class="pl-k">val</span> <span class="pl-en">ptrWidth</span> <span class="pl-k">=</span> log2Up(depth) <span class="pl-k">+</span> <span class="pl-c1">1</span>

  <span class="pl-c">//isFull and isEmpty take gray value as argument and return the corresponding state</span>
  <span class="pl-k">def</span> <span class="pl-en">isFull</span>(<span class="pl-v">a</span>: <span class="pl-en">Bits</span>, <span class="pl-v">b</span>: <span class="pl-en">Bits</span>) <span class="pl-k">=</span> a(ptrWidth <span class="pl-k">-</span> <span class="pl-c1">1</span>, ptrWidth <span class="pl-k">-</span> <span class="pl-c1">2</span>) <span class="pl-k">===</span> <span class="pl-k">~</span>b(ptrWidth <span class="pl-k">-</span> <span class="pl-c1">1</span>, ptrWidth <span class="pl-k">-</span> <span class="pl-c1">2</span>) <span class="pl-k">&amp;&amp;</span> a(ptrWidth <span class="pl-k">-</span> <span class="pl-c1">3</span>, <span class="pl-c1">0</span>) <span class="pl-k">===</span> b(ptrWidth <span class="pl-k">-</span> <span class="pl-c1">3</span>, <span class="pl-c1">0</span>)
  <span class="pl-k">def</span> <span class="pl-en">isEmpty</span>(<span class="pl-v">a</span>: <span class="pl-en">Bits</span>, <span class="pl-v">b</span>: <span class="pl-en">Bits</span>) <span class="pl-k">=</span> a <span class="pl-k">===</span> b

  <span class="pl-k">val</span> <span class="pl-en">ram</span> <span class="pl-k">=</span> <span class="pl-en">Mem</span>(dataType, depth)

  <span class="pl-k">val</span> <span class="pl-en">popToPushGray</span> <span class="pl-k">=</span> <span class="pl-en">Bits</span>(ptrWidth bit)
  <span class="pl-k">val</span> <span class="pl-en">pushToPopGray</span> <span class="pl-k">=</span> <span class="pl-en">Bits</span>(ptrWidth bit)

  <span class="pl-k">val</span> <span class="pl-en">pushLogic</span> <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">ClockingArea</span>(pushClockDomain) {
    <span class="pl-c">//Counter come from SpinalLib,  </span>
    <span class="pl-c">//  It's a UInt register with some logic</span>
    <span class="pl-k">val</span> <span class="pl-en">pushPtr</span> <span class="pl-k">=</span> <span class="pl-en">Counter</span>(depth <span class="pl-k">&lt;&lt;</span> <span class="pl-c1">1</span>)   

    <span class="pl-c">//RegNext is a way to create a register </span>
    <span class="pl-c">//  that take the specified value each cycle</span>
    <span class="pl-c">//toGray is provided by the SpinalLib</span>
    <span class="pl-k">val</span> <span class="pl-en">pushPtrGray</span> <span class="pl-k">=</span> <span class="pl-en">RegNext</span>(toGray(pushPtr.valueNext))

    <span class="pl-c">//Spinal check that there is no unspecified cross clock domain</span>
    <span class="pl-c">//BufferCC is a simple 2 stage (default) register buffer from SpinalLib</span>
    <span class="pl-c">//  B"0" specify it initial value</span>
    <span class="pl-k">val</span> <span class="pl-en">popPtrGray</span> <span class="pl-k">=</span> <span class="pl-en">BufferCC</span>(popToPushGray, <span class="pl-en">B</span><span class="pl-s"><span class="pl-pds">"</span>0<span class="pl-pds">"</span></span>)
    <span class="pl-k">val</span> <span class="pl-en">full</span> <span class="pl-k">=</span> isFull(pushPtrGray, popPtrGray)

    io.push.ready <span class="pl-k">:</span><span class="pl-k">=</span> <span class="pl-k">!</span>full

    <span class="pl-c">//fire is true when a transaction occur (valid &amp;&amp; ready)</span>
    when(io.push.fire) {  
      ram(pushPtr) <span class="pl-k">:</span><span class="pl-k">=</span> io.push.data
      pushPtr <span class="pl-k">++</span>
    }

    <span class="pl-c">//fromGray is provided by the SpinalLib</span>
    io.pushOccupancy <span class="pl-k">:</span><span class="pl-k">=</span> pushPtr <span class="pl-k">-</span> fromGray(popPtrGray)
  }

  <span class="pl-k">val</span> <span class="pl-en">popLogic</span> <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">ClockingArea</span>(popClockDomain) {
    <span class="pl-k">val</span> <span class="pl-en">popPtr</span> <span class="pl-k">=</span> <span class="pl-en">Counter</span>(depth <span class="pl-k">&lt;&lt;</span> <span class="pl-c1">1</span>)
    <span class="pl-k">val</span> <span class="pl-en">popPtrGray</span> <span class="pl-k">=</span> <span class="pl-en">RegNext</span>(toGray(popPtr.valueNext))
    <span class="pl-k">val</span> <span class="pl-en">pushPtrGray</span> <span class="pl-k">=</span> <span class="pl-en">BufferCC</span>(pushToPopGray, <span class="pl-en">B</span><span class="pl-s"><span class="pl-pds">"</span>0<span class="pl-pds">"</span></span>)
    <span class="pl-k">val</span> <span class="pl-en">empty</span> <span class="pl-k">=</span> isEmpty(popPtrGray, pushPtrGray)

    io.pop.valid <span class="pl-k">:</span><span class="pl-k">=</span> <span class="pl-k">!</span>empty
    io.pop.data <span class="pl-k">:</span><span class="pl-k">=</span> ram.readSyncCC(popPtr.valueNext) <span class="pl-c">//Cross clock domain synchronous read</span>
    when(io.pop.fire) {
      popPtr <span class="pl-k">++</span>
    }

    io.popOccupancy <span class="pl-k">:</span><span class="pl-k">=</span> fromGray(pushPtrGray) <span class="pl-k">-</span> popPtr
  }

  pushToPopGray <span class="pl-k">:</span><span class="pl-k">=</span> pushCC.pushPtrGray
  popToPushGray <span class="pl-k">:</span><span class="pl-k">=</span> popCC.popPtrGray
}</pre></div>

<h2>
<a id="example-of-abstraction-with-bus" class="anchor" href="#example-of-abstraction-with-bus" aria-hidden="true"><span class="octicon octicon-link"></span></a>Example of abstraction with bus</h2>

<div class="highlight highlight-scala"><pre>
<span class="pl-k">import</span> <span class="pl-v">spinal.core.</span><span class="pl-v">_</span>
<span class="pl-k">import</span> <span class="pl-v">spinal.lib.</span><span class="pl-v">_</span>

<span class="pl-c">//Define a data structure that is used as configuration of the LogicAnalyser</span>
<span class="pl-k">class</span> <span class="pl-en">LogicAnalyserConfig</span> <span class="pl-k">extends</span> <span class="pl-e">Bundle</span>{
  <span class="pl-k">val</span> <span class="pl-en">trigger</span> <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">Bundle</span>{
    <span class="pl-k">val</span> <span class="pl-en">delay</span> <span class="pl-k">=</span> <span class="pl-en">UInt</span>(<span class="pl-c1">32</span> bit)
    ...
  }
  <span class="pl-k">val</span> <span class="pl-en">logger</span> <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">Bundle</span>{
    <span class="pl-k">val</span> <span class="pl-en">samplesLeftAfterTrigger</span> <span class="pl-k">=</span> <span class="pl-en">UInt</span>(<span class="pl-c1">8</span> bit)
    ...
  }
  ...
}


<span class="pl-c">//Define the LogicAnalyser component</span>
<span class="pl-k">class</span> <span class="pl-en">LogicAnalyser</span> <span class="pl-k">extends</span> <span class="pl-e">Component</span> {
  <span class="pl-k">val</span> <span class="pl-en">io</span> <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">Bundle</span> {
    ...
    <span class="pl-c">//Flow is a very simple bus with the "valid" flag and "data".</span>
    <span class="pl-c">//Fragment is a data type that allow to transport packets with multiple fragment </span>
    <span class="pl-c">//  =&gt; "last" flag and "fragment" data.</span>
    <span class="pl-c">//Flow Fragment(Bits(8 bit)) is a Flow bus that carry Fragment of 8 bit each</span>
    <span class="pl-c">//slavePort carry configuration of the LogicAnalyser</span>
    <span class="pl-k">val</span> <span class="pl-en">slavePort</span> <span class="pl-k">=</span> slave <span class="pl-en">Flow</span> <span class="pl-en">Fragment</span>(<span class="pl-en">Bits</span>(<span class="pl-c1">8</span> bit))
    ...
  }
  ...

  <span class="pl-c">//When the first fragment of one packet is 0x01, then take the next fragment </span>
  <span class="pl-c">//  and save it as Bool into waitTrigger</span>
  <span class="pl-c">//In addition, the initial value of waitTrigger (register reset) is False</span>
  <span class="pl-k">val</span> <span class="pl-en">waitTrigger</span> <span class="pl-k">=</span> io.slavePort filterHeader(<span class="pl-c1">0x01</span>) toRegOf(<span class="pl-en">Bool</span>) init(<span class="pl-en">False</span>)

  <span class="pl-c">//When the first fragment of one packet is 0x02, create a one cycle pulse on userTrigger</span>
  <span class="pl-k">val</span> <span class="pl-en">userTrigger</span> <span class="pl-k">=</span> io.slavePort pulseOn(<span class="pl-c1">0x02</span>)

  <span class="pl-c">//When the first fragment of one packet is 0x0F, </span>
  <span class="pl-c">//  load the configs data structure (LogicAnalyserConfig type)</span>
  <span class="pl-c">//The false argument mean that the configs register is allowed to </span>
  <span class="pl-c">//  take intermediate value when it's unserialize from the slavePort.</span>
  <span class="pl-k">val</span> <span class="pl-en">configs</span> <span class="pl-k">=</span> io.slavePort filterHeader(<span class="pl-c1">0x0F</span>) toRegOf(<span class="pl-k">new</span> <span class="pl-en">LogicAnalyserConfig,false)</span>
  ... 
 }</pre></div>

<p>Function like filterHeader, toRegOf and pulseOn are not hardcoded into the language.
The user can extend it by using the Pimp my library scala pattern.</p>

<p>There is the implementation of filterHeader and pulseOn with pimp my library pattern :</p>

<div class="highlight highlight-scala"><pre><span class="pl-k">package</span> <span class="pl-en">spinal</span>

<span class="pl-k">import</span> <span class="pl-v">spinal.core.</span><span class="pl-v">_</span>

<span class="pl-k">package object</span> <span class="pl-en">lib</span> {
  ...
  <span class="pl-k">implicit</span> <span class="pl-k">def</span> <span class="pl-en">flowFragmentPimpIt</span>[<span class="pl-en">T</span> <span class="pl-k">&lt;</span><span class="pl-k">:</span> <span class="pl-en">Data</span>](<span class="pl-v">that</span> : <span class="pl-en">Flow</span>[<span class="pl-en">Fragment</span>[<span class="pl-en">T</span>]]) <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">FlowFragmentPimpIt</span>[<span class="pl-en">T</span>](that)
  ...
}</pre></div>

<div class="highlight highlight-scala"><pre><span class="pl-k">package</span> <span class="pl-en">spinal.lib</span>

<span class="pl-k">import</span> <span class="pl-v">spinal.core.</span><span class="pl-v">_</span>

<span class="pl-k">class</span> <span class="pl-en">FlowFragmentPimpIt</span>[<span class="pl-en">T</span> <span class="pl-k">&lt;</span><span class="pl-k">:</span> <span class="pl-en">Data</span>](<span class="pl-en">PimpIt</span><span class="pl-k">:</span> <span class="pl-en">Flow</span>[<span class="pl-en">Fragment</span>[<span class="pl-en">T</span>]]) {
  <span class="pl-k">def</span> <span class="pl-en">filterHeader</span>(<span class="pl-v">header</span>: <span class="pl-en">T</span>)<span class="pl-k">:</span> <span class="pl-en">Flow</span>[<span class="pl-en">Fragment</span>[<span class="pl-en">T</span>]] <span class="pl-k">=</span> {
    <span class="pl-k">val</span> <span class="pl-en">takeIt</span> <span class="pl-k">=</span> <span class="pl-en">RegInit</span>(<span class="pl-en">False</span>)

    when(<span class="pl-en">PimpIt</span>.isFirst) {
      when(<span class="pl-en">PimpIt</span>.fragment <span class="pl-k">===</span> header) {
        takeIt <span class="pl-k">:</span><span class="pl-k">=</span> <span class="pl-en">True</span>
      }
    }
    when(<span class="pl-en">PimpIt</span>.isLast) {
      takeIt <span class="pl-k">:</span><span class="pl-k">=</span> <span class="pl-en">False</span>
    }

    <span class="pl-k">return</span> <span class="pl-en">PimpIt</span>.takeWhen(takeIt)
  }

  <span class="pl-k">def</span> <span class="pl-en">pulseOn</span>(<span class="pl-v">header</span>: <span class="pl-en">T</span>)<span class="pl-k">:</span><span class="pl-en">Bool</span> <span class="pl-k">=</span> <span class="pl-en">PimpIt</span>.isFirst <span class="pl-k">&amp;&amp;</span> <span class="pl-en">PimpIt</span>.fragment <span class="pl-k">===</span> header
}</pre></div>

<h2>
<a id="create-an-custom-bus-parametrized-rgb-data-type-operator-overloading-array-of-port-management" class="anchor" href="#create-an-custom-bus-parametrized-rgb-data-type-operator-overloading-array-of-port-management" aria-hidden="true"><span class="octicon octicon-link"></span></a>Create an custom bus, parametrized RGB data type,+ operator overloading, array of port management</h2>

<div class="highlight highlight-scala"><pre><span class="pl-k">import</span> <span class="pl-v">spinal.core.</span><span class="pl-v">_</span>

<span class="pl-c">//Define a Stream interface that use the AXI-like valid/ready handshake</span>
<span class="pl-c">//Transaction's data is a parameterizable type</span>
<span class="pl-c">//This Stream class is already defined into spinal.lib._   It's just to show as a example</span>
<span class="pl-k">case</span> <span class="pl-k">class</span> <span class="pl-en">Stream</span>[<span class="pl-en">T</span> <span class="pl-k">&lt;</span><span class="pl-k">:</span> <span class="pl-en">Data</span>](<span class="pl-v">dataType</span>: <span class="pl-en">T</span>) <span class="pl-k">extends</span> <span class="pl-e">Bundle</span> <span class="pl-k">with</span> <span class="pl-e">IMasterSlave</span> {
  <span class="pl-k">val</span> <span class="pl-en">valid</span> <span class="pl-k">=</span> <span class="pl-en">Bool</span>
  <span class="pl-k">val</span> <span class="pl-en">ready</span> <span class="pl-k">=</span> <span class="pl-en">Bool</span>
  <span class="pl-k">val</span> <span class="pl-en">data</span><span class="pl-k">:</span> <span class="pl-en">T</span> <span class="pl-k">=</span> cloneOf(dataType)

  <span class="pl-c">//Equivalent to SystemVerilog modport</span>
  <span class="pl-k">override</span> <span class="pl-k">def</span> <span class="pl-en">asMaster</span><span class="pl-k">:</span> <span class="pl-v">this</span>.type <span class="pl-k">=</span> {
    out(valid)
    in(ready)
    out(data)
    <span class="pl-v">this</span>
  }

  <span class="pl-k">override</span> <span class="pl-k">def</span> <span class="pl-en">asSlave</span><span class="pl-k">:</span> <span class="pl-v">this</span>.type <span class="pl-k">=</span> asMaster.flip <span class="pl-c">//.flip reverse all signal direction</span>
}

<span class="pl-c">//Define a RGB color data type with parameterizable channel width</span>
<span class="pl-k">case</span> <span class="pl-k">class</span> <span class="pl-en">RGB</span>(<span class="pl-v">rWidth</span>: <span class="pl-k">Int</span>, <span class="pl-v">gWidth</span>: <span class="pl-k">Int</span>, <span class="pl-v">bWidth</span>: <span class="pl-k">Int</span>) <span class="pl-k">extends</span> <span class="pl-e">Bundle</span> {
  <span class="pl-k">val</span> <span class="pl-en">r</span> <span class="pl-k">=</span> <span class="pl-en">UInt</span>(rWidth bit)
  <span class="pl-k">val</span> <span class="pl-en">g</span> <span class="pl-k">=</span> <span class="pl-en">UInt</span>(gWidth bit)
  <span class="pl-k">val</span> <span class="pl-en">b</span> <span class="pl-k">=</span> <span class="pl-en">UInt</span>(bWidth bit)

  <span class="pl-c">//Define the + operator to allow the summation of 2 RGB</span>
  <span class="pl-k">def</span> <span class="pl-en">+</span>(<span class="pl-v">that</span>: <span class="pl-en">RGB</span>)<span class="pl-k">:</span> <span class="pl-en">RGB</span> <span class="pl-k">=</span> {
    <span class="pl-k">val</span> <span class="pl-en">result</span> <span class="pl-k">=</span> cloneOf(<span class="pl-v">this</span>)
    result.r <span class="pl-k">:</span><span class="pl-k">=</span> <span class="pl-v">this</span>.r <span class="pl-k">+</span> that.r
    result.g <span class="pl-k">:</span><span class="pl-k">=</span> <span class="pl-v">this</span>.g <span class="pl-k">+</span> that.g
    result.b <span class="pl-k">:</span><span class="pl-k">=</span> <span class="pl-v">this</span>.b <span class="pl-k">+</span> that.b
    result
  }
}

<span class="pl-c">// Define a component that take "srcCount" slave Stream of RGB</span>
<span class="pl-c">// and product an "sumPort" that is the summation of all "srcPort" with the correct arbitration</span>
<span class="pl-k">case</span> <span class="pl-k">class</span> <span class="pl-en">StreamRgbAdder</span>(<span class="pl-v">rgbType</span>: <span class="pl-en">RGB</span>, <span class="pl-v">srcCount</span>: <span class="pl-k">Int</span>) <span class="pl-k">extends</span> <span class="pl-e">Component</span> {
  <span class="pl-k">val</span> <span class="pl-en">io</span> <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">Bundle</span> {
    <span class="pl-k">val</span> <span class="pl-en">srcPort</span> <span class="pl-k">=</span> <span class="pl-en">Vec</span>(srcCount, slave(<span class="pl-en">Stream</span>(rgbType)))
    <span class="pl-k">val</span> <span class="pl-en">sumPort</span> <span class="pl-k">=</span> master(<span class="pl-en">Stream</span>(rgbType))
  }
  <span class="pl-k">val</span> <span class="pl-en">transactionOccure</span> <span class="pl-k">=</span> io.sumPort.valid <span class="pl-k">&amp;&amp;</span> io.sumPort.ready
  io.sumPort.valid <span class="pl-k">:</span><span class="pl-k">=</span> io.srcPort.map(_.valid).reduce(_ <span class="pl-k">&amp;&amp;</span> _)   <span class="pl-c">//Take all srcPort.valid bits and "AND" them</span>
  io.sumPort.data <span class="pl-k">:</span><span class="pl-k">=</span> io.srcPort.map(_.data).reduce(_ <span class="pl-k">+</span> _)      <span class="pl-c">//Take all srcPort.data (RGB) and "SUM" them by using the overloaded + operator from RGB class</span>
  io.srcPort.foreach(_.ready <span class="pl-k">:</span><span class="pl-k">=</span> transactionOccure)             <span class="pl-c">//For each srcPort.ready assign the transactionOccure</span>
}


<span class="pl-k">def</span> <span class="pl-en">main</span>(<span class="pl-v">args</span>: <span class="pl-en">Array</span>[<span class="pl-k">String</span>]) {
  <span class="pl-en">SpinalVhdl</span>(<span class="pl-en">StreamRgbAdder</span>(<span class="pl-en">RGB</span>(<span class="pl-c1">5</span>, <span class="pl-c1">6</span>, <span class="pl-c1">5</span>), <span class="pl-c1">4</span>)) <span class="pl-c">//Generate the VHDL for a 4 srcPort and a RGB config of 5,6,5 bits</span>
}</pre></div>

<h2>
<a id="why-not-chisel-" class="anchor" href="#why-not-chisel-" aria-hidden="true"><span class="octicon octicon-link"></span></a>Why not Chisel ?</h2>

<p>It's a real question, why SpinalHDL was implemented while there Chisel already existing from 3 years ago.
Chisel is a big step forward compared to common HDL,
but when come serious design that mix multiple clock domain and external IP (blackbox), Chisel show some serious conception issue : </p>

<p>Multiple clock support is awkward :</p>

<ul>
<li>Working into a single block with multiple clock is difficult, you can't define "ClockingArea", only creating a module allow it</li>
<li>Reset wire is not really integrated into the clock domain notion, sub module lose reset of parent and it's really annoying</li>
<li>No support of falling edge clock, active low reset</li>
<li>No clock enable support</li>
<li>Chisel make the assumption that every clock wire come from the top level inputs, you don't have access to clock signal</li>
</ul>

<p>Black box support is far from good :</p>

<ul>
<li>Generic/Parameter are not really supported</li>
<li>Specify clock input for a black box is not supported. You have to use workaround and you don't have any control on clock signal name and change against your will</li>
</ul>

<p>Syntax could be better :</p>

<ul>
<li>Not pretty literal value syntax, No implicit conversion between Scala and Chisel types</li>
<li>Not pretty input/output definition</li>
<li>Assignment operator is only checked when you generate the code, the IDE can't check it for you. Bundle assignment operator is weak typed.</li>
<li>Switch statement doesn't have default case</li>
<li>No "Area" notion to give a better structure to the user code</li>
</ul>

<p>Various issue :</p>

<ul>
<li>You can't define function without argument into Bundles</li>
<li>There is no notion of "Area" </li>
<li>Using when/otherwise is not strict in all case, then it allow you to generate an asynchronous signal that is not assigned in all case.</li>
<li>You can't really write a given range of bit into a bit vector.</li>
<li>The library that is integrated into Chisel and give you some utils and useful bus definition is a good intention, but could be so better and more complete</li>
</ul>

<p>For a lot of issue listed here, an issue/pull request was open on github, but doesn't have any following. In addition, if we consider the age (3 years) of Chisel,this is a very serious issue and it's why SpinalHDL was created.</p>

<h1>
<a id="other-consideration" class="anchor" href="#other-consideration" aria-hidden="true"><span class="octicon octicon-link"></span></a>Other consideration</h1>

<p>Intellij scala plugin has some syntax highlight bug. Please use scala plugin &gt;= 1.4</p>
      </section>

    </div>
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->
    
  </body>
</html>
