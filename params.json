{"name":"SpinalHDL","tagline":"SpinalHDL","body":"About SpinalHDL\r\n============\r\nSpinalHDL is a scala library that allows the user to describe his digital hardware and then generate the corresponding VHDL file.\r\n## Advantages over VHDL/Verilog\r\n- No restriction to the genericity of your hardware description by using Scala constructs\r\n- No more endless wiring. Create and connect complex buses like AXI in one line.\r\n- Evolving capabilities. Create your own buses definition and abstraction layer.\r\n- Reduce code size by a high factor, especially for wiring. Allowing you to have a better visibility, more productivity and fewer headaches.\r\n- Free and user friendly IDE. Thanks to scala world for auto-completion, error highlight, navigation shortcut and many others\r\n- Extract information from your digital design and then generate files that contain information about some latency and addresses\r\n- Bidirectional translation between any data type and bits. Useful to load a complex data structure from a CPU interface.\r\n- Check for you that there is no combinational loop / latch\r\n- Check that there is no user unintentional cross clock domain\r\n\r\nGetting started\r\n===============\r\n## Links\r\n- There is a SBT base project                     <br> https://github.com/SpinalHDL/SpinalBaseProject\r\n- There is a presentation of the language there   <br> https://github.com/SpinalHDL/SpinalDoc/tree/master/presentation/en (pptx has comments)\r\n- There is a small paper about it there           <br> https://github.com/SpinalHDL/SpinalDoc/tree/master/paper/en\r\n\r\n## Basics\r\n- VHDL backend : The digital hardware description is flushed into a synthesizable VHDL file\r\n- Base Types : Bool, Bits, UInt, SInt, Enumeration\r\n- Bundle : That allow you to describe a data structure with the possibility for each element to specify the direction (in,out). That is useful to describe bus\r\n- Reg : Create a register signal\r\n- Vec : That allow you to create an array of data\r\n- Mem : Give the possibility to manipulate memory\r\n- BlackBox : Allow you to instantiate a third party HDL component\r\n\r\n## SBT\r\n\r\n```scala\r\nscalaVersion := \"2.11.6\"\r\n\r\nlibraryDependencies ++= Seq(\r\n  \"com.github.spinalhdl\" % \"spinalhdl-core_2.11\" % \"latest.release\",\r\n  \"com.github.spinalhdl\" % \"spinalhdl-lib_2.11\" % \"latest.release\"\r\n)\r\n```\r\n\r\n## JAR\r\n\r\n    https://oss.sonatype.org/content/groups/public/com/github/spinalhdl/spinalhdl-core_2.11/\r\n    https://oss.sonatype.org/content/groups/public/com/github/spinalhdl/spinalhdl-lib_2.11/\r\n\r\n\r\nExamples\r\n===============\r\n## Simple component\r\n\r\n```scala\r\n// spinal.core contain all basics (Bool, UInt, Bundle, Reg, Component, ..)\r\nimport spinal.core._  \r\n\r\n//A simple component definition\r\nclass MyTopLevel extends Component {\r\n  //Define some input/output. Bundle like a VHDL record or a verilog struct.\r\n  val io = new Bundle {\r\n    val a = in Bool\r\n    val b = in Bool\r\n    val c = out Bool\r\n  }\r\n  \r\n  //Define some asynchronous logic\r\n  io.c := io.a & io.b\r\n}\r\n\r\n//This is the main of the project. It create a instance of MyTopLevel and \r\n//call the SpinalHDL library to flush it into a VHDL file.\r\nobject MyMain {\r\n  def main(args: Array[String]) {\r\n    SpinalVhdl(new MyTopLevel)\r\n  }\r\n}\r\n```\r\n\r\n## Carry adder\r\n\r\n```scala\r\nimport spinal.core._\r\n\r\nclass CarryAdder(size : Int) extends Component{\r\n  val io = new Bundle{\r\n    val a = in UInt(size bit)\r\n    val b = in UInt(size bit)\r\n    val result = out UInt(size bit)      //result = a + b\r\n  }\r\n\r\n  var c = False                   //Carry, like a VHDL variable\r\n  for (i <- 0 until size) {\r\n\t//Create some intermediate value in the loop scope.\r\n    val a = io.a(i)\t \r\n    val b = io.b(i)  \r\n\t\r\n\t//The carry adder's asynchronous logic\r\n    io.result(i) := a ^ b ^ c\r\n    c = (a & b) | (a & c) | (b & c);    //variable assignment\r\n  }\r\n}\r\n\r\n\r\nobject CarryAdderProject {\r\n  def main(args: Array[String]) {\r\n    SpinalVhdl(new CarryAdder(4))\r\n  }\r\n}\r\n```\r\n\r\n## Counter with parity\r\n\r\n```scala\r\nclass CounterWithParity(size : Int) extends Component{\r\n  val io = new Bundle{\r\n    val increment = in Bool\r\n    val value = out UInt(size bit)\r\n    val evenParity = out Bool\r\n  }\r\n\r\n  //Create a register of UInt(size-1 downto 0) \r\n  //init(0) force it to zero when a reset occur\r\n  //In Spinal, you don't have to play with clock and reset signals each time\r\n  //  you create register. You define a clock domain area and this is done.\r\n  val counter = Reg(UInt(size bit)) init(0)\r\n  when(io.increment){\r\n    counter := counter + 1\r\n  }\r\n  \r\n  //Get all bit of counter and then xor them together\r\n  //toBools create a vector of Bool from each bit of counter\r\n  //reduceLeft is a scala function that mix all bit together \r\n  //  from the left to the right\r\n  io.evenParity := counter.toBools.reduceLeft(_ ^ _)   \r\n\r\n  io.value := counter\r\n}\r\n```\r\n\r\n## Interface / Custom data types / Multi clock system\r\n\r\n```scala\r\n// spinal.core contain all basics (Bool, UInt, Bundle, Reg, Component, ..)\r\nimport spinal.core._\r\n\r\n// spinal.lib contain some abstraction built over the spinal.core like\r\n//   utils          : log2up, toGray, fromGray, \r\n//                    majority vote, latency analysis (in cycle)\r\n//   bus            : Flow      (valid, data)\r\n//                    Stream (valid, ready, data)\r\n//                    Flow or Stream of Fragment  ( .. , last, data),\r\n//   abstraction    : counter, timeout,\r\n//   implementation : stream fifo/arbiter/fork, UART controller\r\nimport spinal.lib._\r\n\r\n//Define custom data types.\r\n//You can use Bundle into Bundle\r\nclass MyDataType extends Bundle{\r\n  val a = UInt(8 bit)\r\n  val b = Bool\r\n  val c = Vec(4,Bool) //Create a array of 4 Bool\r\n}\r\n\r\nclass MultiClockTopLevel extends Component {\r\n  val io = new Bundle {\r\n    val clkA = in Bool\r\n    val resetA = in Bool\r\n    val clkB = in Bool\r\n    val resetB = in Bool\r\n\r\n    //Create stream interface (valid, ready, data) to transport MyDataType data\r\n    val slaveInteface = slave Stream(new MyDataType)\r\n    val masterInterface = master Stream(new MyDataType)\r\n  }\r\n\r\n  //Create clock domains from inputs clocks and resets\r\n  val clockDomainA = ClockDomain(io.clkA,io.resetA)\r\n  val clockDomainB = ClockDomain(io.clkB,io.resetB)\r\n\r\n  //Create a fifo able to cross clock domain a stream of MyDataType\r\n  val fifo = new StreamFifoCC(new MyDataType,16,clockDomainA,clockDomainB)\r\n  fifo.io.push << io.slaveInteface    //Easy connection provided by Stream library\r\n  fifo.io.pop >> io.masterInterface\r\n}\r\n\r\n\r\nobject MultiClockTopLevel {\r\n  def main(args: Array[String]) {\r\n    SpinalVhdl(new MultiClockTopLevel)\r\n  }\r\n}\r\n```\r\n\r\n## Dual clock FIFO\r\n\r\n```scala\r\nimport spinal.core._\r\nimport spinal.lib._\r\n\r\nclass StreamFifoCC[T <: Data](dataType: T, depth: Int, pushClockDomain: ClockDomain, popClockDomain: ClockDomain) extends Component {\r\n  assert(isPow2(depth))\r\n  assert(depth >= 2)\r\n\r\n  val io = new Bundle {\r\n    val push = slave Stream (dataType)\r\n    val pop = master Stream (dataType)\r\n\t\r\n    val pushOccupancy = out UInt (log2Up(depth) + 1 bit)\r\n    val popOccupancy = out UInt (log2Up(depth) + 1 bit)\r\n  }\r\n\r\n  val ptrWidth = log2Up(depth) + 1\r\n  \r\n  //isFull and isEmpty take gray value as argument and return the corresponding state\r\n  def isFull(a: Bits, b: Bits) = a(ptrWidth - 1, ptrWidth - 2) === ~b(ptrWidth - 1, ptrWidth - 2) && a(ptrWidth - 3, 0) === b(ptrWidth - 3, 0)\r\n  def isEmpty(a: Bits, b: Bits) = a === b\r\n\r\n  val ram = Mem(dataType, depth)\r\n\r\n  val popToPushGray = Bits(ptrWidth bit)\r\n  val pushToPopGray = Bits(ptrWidth bit)\r\n\r\n  val pushLogic = new ClockingArea(pushClockDomain) {\r\n\t//Counter come from SpinalLib, \t\r\n\t//  It's a UInt register with some logic\r\n    val pushPtr = Counter(depth << 1)\t\r\n\t\r\n\t//RegNext is a way to create a register \r\n\t//  that take the specified value each cycle\r\n\t//toGray is provided by the SpinalLib\r\n    val pushPtrGray = RegNext(toGray(pushPtr.valueNext))\r\n\t\r\n\t//Spinal check that there is no unspecified cross clock domain\r\n\t//BufferCC is a simple 2 stage (default) register buffer from SpinalLib\r\n\t//  B\"0\" specify it initial value\r\n    val popPtrGray = BufferCC(popToPushGray, B\"0\")\r\n    val full = isFull(pushPtrGray, popPtrGray)\r\n\r\n    io.push.ready := !full\r\n\t\r\n\t//fire is true when a transaction occur (valid && ready)\r\n    when(io.push.fire) {  \r\n      ram(pushPtr) := io.push.data\r\n      pushPtr ++\r\n    }\r\n\t\r\n\t//fromGray is provided by the SpinalLib\r\n    io.pushOccupancy := pushPtr - fromGray(popPtrGray)\r\n  }\r\n\r\n  val popLogic = new ClockingArea(popClockDomain) {\r\n    val popPtr = Counter(depth << 1)\r\n    val popPtrGray = RegNext(toGray(popPtr.valueNext))\r\n    val pushPtrGray = BufferCC(pushToPopGray, B\"0\")\r\n    val empty = isEmpty(popPtrGray, pushPtrGray)\r\n\r\n    io.pop.valid := !empty\r\n    io.pop.data := ram.readSyncCC(popPtr.valueNext) //Cross clock domain synchronous read\r\n    when(io.pop.fire) {\r\n      popPtr ++\r\n    }\r\n\r\n    io.popOccupancy := fromGray(pushPtrGray) - popPtr\r\n  }\r\n\r\n  pushToPopGray := pushCC.pushPtrGray\r\n  popToPushGray := popCC.popPtrGray\r\n}\r\n```\r\n\r\n## Example of abstraction with bus\r\n\r\n```scala\r\n\r\nimport spinal.core._\r\nimport spinal.lib._\r\n\r\n//Define a data structure that is used as configuration of the LogicAnalyser\r\nclass LogicAnalyserConfig extends Bundle{\r\n  val trigger = new Bundle{\r\n    val delay = UInt(32 bit)\r\n    ...\r\n  }\r\n  val logger = new Bundle{\r\n    val samplesLeftAfterTrigger = UInt(8 bit)\r\n    ...\r\n  }\r\n  ...\r\n}\r\n\r\n\r\n//Define the LogicAnalyser component\r\nclass LogicAnalyser extends Component {\r\n  val io = new Bundle {\r\n    ...\r\n    //Flow is a very simple bus with the \"valid\" flag and \"data\".\r\n    //Fragment is a data type that allow to transport packets with multiple fragment \r\n    //  => \"last\" flag and \"fragment\" data.\r\n    //Flow Fragment(Bits(8 bit)) is a Flow bus that carry Fragment of 8 bit each\r\n    //slavePort carry configuration of the LogicAnalyser\r\n    val slavePort = slave Flow Fragment(Bits(8 bit))\r\n    ...\r\n  }\r\n  ...\r\n\r\n  //When the first fragment of one packet is 0x01, then take the next fragment \r\n  //  and save it as Bool into waitTrigger\r\n  //In addition, the initial value of waitTrigger (register reset) is False\r\n  val waitTrigger = io.slavePort filterHeader(0x01) toRegOf(Bool) init(False)\r\n  \r\n  //When the first fragment of one packet is 0x02, create a one cycle pulse on userTrigger\r\n  val userTrigger = io.slavePort pulseOn(0x02)\r\n  \r\n  //When the first fragment of one packet is 0x0F, \r\n  //  load the configs data structure (LogicAnalyserConfig type)\r\n  //The false argument mean that the configs register is allowed to \r\n  //  take intermediate value when it's unserialize from the slavePort.\r\n  val configs = io.slavePort filterHeader(0x0F) toRegOf(new LogicAnalyserConfig,false)\r\n  ... \r\n }\r\n```\r\n\r\nFunction like filterHeader, toRegOf and pulseOn are not hardcoded into the language.\r\nThe user can extend it by using the Pimp my library scala pattern.\r\n\r\nThere is the implementation of filterHeader and pulseOn with pimp my library pattern :\r\n```scala\r\npackage spinal\r\n\r\nimport spinal.core._\r\n\r\npackage object lib {\r\n  ...\r\n  implicit def flowFragmentPimpIt[T <: Data](that : Flow[Fragment[T]]) = new FlowFragmentPimpIt[T](that)\r\n  ...\r\n}\r\n```\r\n\r\n```scala\r\npackage spinal.lib\r\n\r\nimport spinal.core._\r\n\r\nclass FlowFragmentPimpIt[T <: Data](PimpIt: Flow[Fragment[T]]) {\r\n  def filterHeader(header: T): Flow[Fragment[T]] = {\r\n    val takeIt = RegInit(False)\r\n\r\n    when(PimpIt.isFirst) {\r\n      when(PimpIt.fragment === header) {\r\n        takeIt := True\r\n      }\r\n    }\r\n    when(PimpIt.isLast) {\r\n      takeIt := False\r\n    }\r\n\r\n    return PimpIt.takeWhen(takeIt)\r\n  }\r\n\r\n  def pulseOn(header: T):Bool = PimpIt.isFirst && PimpIt.fragment === header\r\n}\r\n```\r\n\r\n\r\n## Create an custom bus, parametrized RGB data type,+ operator overloading, array of port management\r\n```scala\r\nimport spinal.core._\r\n\r\n//Define a Stream interface that use the AXI-like valid/ready handshake\r\n//Transaction's data is a parameterizable type\r\n//This Stream class is already defined into spinal.lib._   It's just to show as a example\r\ncase class Stream[T <: Data](dataType: T) extends Bundle with IMasterSlave {\r\n  val valid = Bool\r\n  val ready = Bool\r\n  val data: T = cloneOf(dataType)\r\n\r\n  //Equivalent to SystemVerilog modport\r\n  override def asMaster: this.type = {\r\n    out(valid)\r\n    in(ready)\r\n    out(data)\r\n    this\r\n  }\r\n\r\n  override def asSlave: this.type = asMaster.flip //.flip reverse all signal direction\r\n}\r\n\r\n//Define a RGB color data type with parameterizable channel width\r\ncase class RGB(rWidth: Int, gWidth: Int, bWidth: Int) extends Bundle {\r\n  val r = UInt(rWidth bit)\r\n  val g = UInt(gWidth bit)\r\n  val b = UInt(bWidth bit)\r\n\r\n  //Define the + operator to allow the summation of 2 RGB\r\n  def +(that: RGB): RGB = {\r\n    val result = cloneOf(this)\r\n    result.r := this.r + that.r\r\n    result.g := this.g + that.g\r\n    result.b := this.b + that.b\r\n    result\r\n  }\r\n}\r\n\r\n// Define a component that take \"srcCount\" slave Stream of RGB\r\n// and product an \"sumPort\" that is the summation of all \"srcPort\" with the correct arbitration\r\ncase class StreamRgbAdder(rgbType: RGB, srcCount: Int) extends Component {\r\n  val io = new Bundle {\r\n    val srcPort = Vec(srcCount, slave(Stream(rgbType)))\r\n    val sumPort = master(Stream(rgbType))\r\n  }\r\n  val transactionOccure = io.sumPort.valid && io.sumPort.ready\r\n  io.sumPort.valid := io.srcPort.map(_.valid).reduce(_ && _)   //Take all srcPort.valid bits and \"AND\" them\r\n  io.sumPort.data := io.srcPort.map(_.data).reduce(_ + _)      //Take all srcPort.data (RGB) and \"SUM\" them by using the overloaded + operator from RGB class\r\n  io.srcPort.foreach(_.ready := transactionOccure)             //For each srcPort.ready assign the transactionOccure\r\n}\r\n\r\n\r\ndef main(args: Array[String]) {\r\n  SpinalVhdl(StreamRgbAdder(RGB(5, 6, 5), 4)) //Generate the VHDL for a 4 srcPort and a RGB config of 5,6,5 bits\r\n}\r\n```\r\n\r\n## Why not Chisel ?\r\nIt's a real question, why SpinalHDL was implemented while there Chisel already existing from 3 years ago.\r\nChisel is a big step forward compared to common HDL,\r\nbut when come serious design that mix multiple clock domain and external IP (blackbox), Chisel show some serious conception issue : \r\n\r\nMultiple clock support is awkward :\r\n- Working into a single block with multiple clock is difficult, you can't define \"ClockingArea\", only creating a module allow it\r\n- Reset wire is not really integrated into the clock domain notion, sub module lose reset of parent and it's really annoying\r\n- No support of falling edge clock, active low reset\r\n- No clock enable support\r\n- Chisel make the assumption that every clock wire come from the top level inputs, you don't have access to clock signal\r\n\r\nBlack box support is far from good :\r\n- Generic/Parameter are not really supported\r\n- Specify clock input for a black box is not supported. You have to use workaround and you don't have any control on clock signal name and change against your will\r\n\r\nSyntax could be better :\r\n- Not pretty literal value syntax, No implicit conversion between Scala and Chisel types\r\n- Not pretty input/output definition\r\n- Assignment operator is only checked when you generate the code, the IDE can't check it for you. Bundle assignment operator is weak typed.\r\n- Switch statement doesn't have default case\r\n- No \"Area\" notion to give a better structure to the user code\r\n\r\nVarious issue :\r\n- You can't define function without argument into Bundles\r\n- There is no notion of \"Area\" \r\n- Using when/otherwise is not strict in all case, then it allow you to generate an asynchronous signal that is not assigned in all case.\r\n- You can't really write a given range of bit into a bit vector.\r\n- The library that is integrated into Chisel and give you some utils and useful bus definition is a good intention, but could be so better and more complete\r\n\r\nFor a lot of issue listed here, an issue/pull request was open on github, but doesn't have any following. In addition, if we consider the age (3 years) of Chisel,this is a very serious issue and it's why SpinalHDL was created.\r\n\r\nOther consideration\r\n===============\r\nIntellij scala plugin has some syntax highlight bug. Please use scala plugin >= 1.4\r\n\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}